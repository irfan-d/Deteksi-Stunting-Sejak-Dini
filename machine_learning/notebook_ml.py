# -*- coding: utf-8 -*-
"""notebook_ml.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ugQdU_AfxgPV_2kFJF1DM3MCDjzqFn4E
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd

# ID dari file spreadsheet
file_id = '1jjuDbfl8hqwurHCDHahxktcpG8M0BRQY'

# Format URL export ke CSV
csv_url = f'https://drive.google.com/uc?id={file_id}&export=download'

# Load ke DataFrame
df = pd.read_csv(csv_url)

# Lihat 5 data awal
df.head()

# Statistik deskriptif
df.describe()

# Statistik deskriptif
df.describe()

# Total nilai kosong per kolom
print("Jumlah missing value:")
print(df.isnull().sum())

# Atau dalam bentuk persen
print("\nPersentase missing value:")
print(df.isnull().mean() * 100)

# Cek jumlah baris yang duplikat di seluruh kolom
jumlah_duplikat = df.duplicated(keep=False).sum()
print("Jumlah baris duplikat (seluruh kolom sama persis):", jumlah_duplikat)

# Tampilkan baris duplikat (termasuk yang pertama)
df_duplikat = df[df.duplicated(keep=False)]
print("\nBaris-baris duplikat:")
display(df_duplikat.sort_values(by=df.columns.tolist()).reset_index(drop=True))

# Distribusi target
print("Distribusi kelas 'Stunting':")
print(df['Stunting'].value_counts())
print("\nPersentase:")
print(df['Stunting'].value_counts(normalize=True) * 100)

# Cek kategori unik
print("Gender:", df['Gender'].unique())
print("Breastfeeding:", df['Breastfeeding'].unique())

import seaborn as sns
import matplotlib.pyplot as plt

# Plot distribusi kolom numerik
numerik_cols = ['Age', 'Birth Weight', 'Birth Length', 'Body Weight', 'Body Length']
plt.figure(figsize=(15, 8))
for i, col in enumerate(numerik_cols):
    plt.subplot(2, 3, i+1)
    sns.boxplot(x=df[col])
    plt.title(f'Distribusi {col}')
plt.tight_layout()
plt.show()

import seaborn as sns
import matplotlib.pyplot as plt

# Visualisasi distribusi Stunting berdasarkan Gender
plt.figure(figsize=(6, 4))
sns.countplot(data=df, x='Gender', hue='Stunting')
plt.title('Distribusi Stunting Berdasarkan Gender')
plt.xlabel('Gender (0=female, 1=male)')
plt.ylabel('Count')
plt.show()

# Visualisasi distribusi Stunting berdasarkan Breastfeeding
plt.figure(figsize=(6, 4))
sns.countplot(data=df, x='Breastfeeding', hue='Stunting')
plt.title('Distribusi Stunting Berdasarkan Breastfeeding')
plt.xlabel('Breastfeeding (0=No, 1=Yes)')
plt.ylabel('Count')
plt.show()

# Visualisasi distribusi Age terhadap Stunting
plt.figure(figsize=(8, 6))
sns.boxplot(data=df, x='Stunting', y='Age')
plt.title('Distribusi Age terhadap Stunting')
plt.xlabel('Stunting (0=No, 1=Yes)')
plt.ylabel('Age')
plt.show()

# Visualisasi distribusi Body Weight terhadap Stunting
plt.figure(figsize=(8, 6))
sns.boxplot(data=df, x='Stunting', y='Body Weight')
plt.title('Distribusi Body Weight terhadap Stunting')
plt.xlabel('Stunting (0=No, 1=Yes)')
plt.ylabel('Body Weight')
plt.show()

# Visualisasi scatter plot Body Length vs Stunting
plt.figure(figsize=(8, 6))
sns.scatterplot(data=df, x='Body Length', y='Birth Weight', hue='Stunting', palette='coolwarm')
plt.title('Hubungan Body Length dan Birth Weight dengan Stunting')
plt.xlabel('Body Length')
plt.ylabel('Birth Weight')
plt.legend(title='Stunting', loc='upper right')
plt.show()

# Visualisasi pairplot untuk fitur numerik
sns.pairplot(df, hue='Stunting', vars=['Age', 'Body Weight', 'Body Length'])
plt.suptitle('Pairplot: Hubungan antara Fitur Numerik dengan Stunting', y=1.02)
plt.show()

# Korelasi numerik
correlation = df[numerik_cols].corr()

# Heatmap
plt.figure(figsize=(8, 6))
sns.heatmap(correlation, annot=True, cmap='coolwarm')
plt.title('Korelasi antar fitur numerik')
plt.show()

# Salin dataframe agar tidak merusak aslinya
df_encoded = df.copy()

# Mapping manual (karena biner)
df_encoded['Gender'] = df_encoded['Gender'].map({'male': 1, 'female': 0})
df_encoded['Breastfeeding'] = df_encoded['Breastfeeding'].map({'Yes': 1, 'No': 0})
df_encoded['Stunting'] = df_encoded['Stunting'].map({'Yes': 1, 'No': 0})

# Cek hasil
df_encoded.head()

import seaborn as sns
import matplotlib.pyplot as plt

# Hitung korelasi antar fitur
corr_matrix = df_encoded.corr()

# Tampilkan heatmap korelasi
plt.figure(figsize=(10, 8))
sns.heatmap(corr_matrix, annot=True, cmap='coolwarm', fmt='.2f', linewidths=0.5)
plt.title('Matriks Korelasi Fitur')
plt.show()

from sklearn.model_selection import train_test_split

# Pisahkan fitur (X) dan target (y)
X = df_encoded.drop('Stunting', axis=1)  # Fitur
y = df_encoded['Stunting']  # Target

# Split data menjadi train + val (80%) dan test (20%)
X_train_val, X_test, y_train_val, y_test = train_test_split(X, y, test_size=0.2, random_state=42, stratify=y)

# Split data train + val menjadi train (60%) dan validation (20%)
X_train, X_val, y_train, y_val = train_test_split(X_train_val, y_train_val, test_size=0.25, random_state=42, stratify=y_train_val)

# Cek dimensi setelah split
print("Train:", X_train.shape, "Validation:", X_val.shape, "Test:", X_test.shape)

from sklearn.feature_selection import RFE
from sklearn.linear_model import LogisticRegression

# Inisialisasi model Logistic Regression
model = LogisticRegression(random_state=42)

# Inisialisasi RFE (misalnya ambil 5 fitur terpenting)
rfe = RFE(estimator=model, n_features_to_select=5)

# Fit RFE dengan data train
rfe.fit(X_train, y_train)

# Fitur yang dipilih oleh RFE
selected_features = X_train.columns[rfe.support_]
print("Fitur terpilih:", selected_features)

import joblib

# Simpan feature selector
joblib.dump(rfe, 'feature_selector.pkl')

# Pilih fitur terpilih
X_train_selected = X_train[selected_features]
X_val_selected = X_val[selected_features]
X_test_selected = X_test[selected_features]

# Cek dimensi data setelah seleksi fitur
print("Train selected features:", X_train_selected.shape)
print("Validation selected features:", X_val_selected.shape)
print("Test selected features:", X_test_selected.shape)

from sklearn.preprocessing import StandardScaler

# Inisialisasi scaler
scaler = StandardScaler()

# Fit dan transform data train, lalu hanya transform untuk validation dan test
X_train_scaled = scaler.fit_transform(X_train_selected)
X_val_scaled = scaler.transform(X_val_selected)
X_test_scaled = scaler.transform(X_test_selected)

# Cek hasil normalisasi
print("Train scaled:", X_train_scaled[:5])

# Simpan scaler
joblib.dump(scaler, 'scaler.pkl')

import tensorflow as tf

# Konversi data ke bentuk tensor
X_train_tensor = tf.convert_to_tensor(X_train_scaled, dtype=tf.float32)
X_val_tensor = tf.convert_to_tensor(X_val_scaled, dtype=tf.float32)
X_test_tensor = tf.convert_to_tensor(X_test_scaled, dtype=tf.float32)

y_train_tensor = tf.convert_to_tensor(y_train, dtype=tf.float32)
y_val_tensor = tf.convert_to_tensor(y_val, dtype=tf.float32)
y_test_tensor = tf.convert_to_tensor(y_test, dtype=tf.float32)

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout

# Bangun model Sequential
model = Sequential()

# Input layer dan hidden layer pertama (64 unit)
model.add(Dense(64, input_dim=X_train_tensor.shape[1], activation='relu'))

# Tambahkan Dropout untuk regularisasi
model.add(Dropout(0.5))

# Hidden layer kedua (32 unit)
model.add(Dense(32, activation='relu'))

# Output layer (1 unit untuk klasifikasi biner)
model.add(Dense(1, activation='sigmoid'))

# Kompilasi model dengan loss binary_crossentropy, optimizer Adam, dan metrics akurasi
model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])

# Ringkasan model
model.summary()

# Latih model
history = model.fit(X_train_tensor, y_train_tensor, epochs=50, batch_size=32, validation_data=(X_val_tensor, y_val_tensor))

# Visualisasi training vs validation loss
import matplotlib.pyplot as plt

plt.plot(history.history['loss'], label='Train Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.title('Loss vs Epochs')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.legend()
plt.show()

# Visualisasi akurasi training vs validation
plt.plot(history.history['accuracy'], label='Train Accuracy')
plt.plot(history.history['val_accuracy'], label='Validation Accuracy')
plt.title('Accuracy vs Epochs')
plt.xlabel('Epochs')
plt.ylabel('Accuracy')
plt.legend()
plt.show()

# Evaluasi model
test_loss, test_accuracy = model.evaluate(X_test_tensor, y_test_tensor)
print(f'Test Loss: {test_loss:.4f}')
print(f'Test Accuracy: {test_accuracy:.4f}')

from sklearn.metrics import confusion_matrix
import seaborn as sns

# Prediksi pada data test
y_pred = model.predict(X_test_tensor)

# Konversi probabilitas ke label (0 atau 1)
y_pred_labels = (y_pred > 0.5).astype(int)

# Hitung confusion matrix
cm = confusion_matrix(y_test_tensor, y_pred_labels)

# Visualisasi confusion matrix
plt.figure(figsize=(6, 5))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=['No Stunting', 'Stunting'], yticklabels=['No Stunting', 'Stunting'])
plt.title('Confusion Matrix')
plt.xlabel('Predicted Labels')
plt.ylabel('True Labels')
plt.show()

from sklearn.metrics import classification_report

# Tampilkan classification report
print("Classification Report:")
print(classification_report(y_test_tensor, y_pred_labels, target_names=['No Stunting', 'Stunting']))

# Prediksi pada data test
y_pred = model.predict(X_test_tensor)

# Konversi probabilitas ke label (0 atau 1)
y_pred_labels = (y_pred > 0.5).astype(int)

# Tampilkan beberapa hasil prediksi
print("Prediksi:", y_pred_labels[:10].flatten())
print("Aktual:", y_test_tensor[:10].numpy())

# Simpan model ke dalam format HDF5 (.h5)
model.save('stunting_model.h5')

# Gunakan TFLiteConverter untuk mengonversi model ke format TFLite
converter = tf.lite.TFLiteConverter.from_keras_model(model)

# Opsional: Mengoptimalkan model untuk perangkat dengan sumber daya terbatas
converter.optimizations = [tf.lite.Optimize.DEFAULT]

# Convert model ke format TFLite
tflite_model = converter.convert()

# Simpan model TFLite ke file
with open('stunting_model.tflite', 'wb') as f:
    f.write(tflite_model)

# Simpan arsitektur model ke dalam file JSON
model_json = model.to_json()
with open('stunting_model_architecture.json', 'w') as json_file:
    json_file.write(model_json)

# Simpan bobot model ke dalam format HDF5
model.save_weights('stunting_model.weights.h5')

import tensorflow as tf
import numpy as np
import pandas as pd

# Muat model yang sudah disimpan (gunakan path file yang sesuai dengan model Anda)
model = tf.keras.models.load_model('stunting_model.h5')

# Ambil data test (asumsi kita sudah split data sebelumnya)
X_test = df_encoded[['Gender', 'Age', 'Birth Weight', 'Body Length', 'Breastfeeding']].values
y_test = df_encoded['Stunting'].values

# Pilih salah satu data test (misalnya data ke-10)
index = 15
sample_input = X_test[index]
actual_label = y_test[index]

# Melakukan prediksi
prediction = model.predict(sample_input.reshape(1, -1))

# Menampilkan hasil prediksi dan nilai aktual
predicted_label = 1 if prediction[0][0] > 0.5 else 0  # Mengubah output menjadi biner

# Tampilkan hasil
print(f"Data Test (Index: {index}):")
print(f"Gender: {sample_input[0]}, Age: {sample_input[1]}, Birth Weight: {sample_input[2]}, "
      f"Body Length: {sample_input[3]}, Breastfeeding: {sample_input[4]}")

print("\nHasil Prediksi:")
print("Prediksi Stunting (1: Yes, 0: No):", predicted_label)

print("\nNilai Aktual:")
print("Aktual Stunting (1: Yes, 0: No):", actual_label)

import pandas as pd

# Konversi dari angka kembali ke label asli
gender_map_reverse = {0: 'female', 1: 'male'}
breastfeeding_map_reverse = {0: 'No', 1: 'Yes'}

# Konversi X_test dan X_val ke dataframe
X_test_df = pd.DataFrame(X_test, columns=['Gender', 'Age', 'Birth Weight', 'Body Length', 'Breastfeeding'])
X_val_df = pd.DataFrame(X_val, columns=['Gender', 'Age', 'Birth Weight', 'Body Length', 'Breastfeeding'])

# Ubah kolom kategori ke bentuk asli
X_test_df['Gender'] = X_test_df['Gender'].map(gender_map_reverse)
X_test_df['Breastfeeding'] = X_test_df['Breastfeeding'].map(breastfeeding_map_reverse)

X_val_df['Gender'] = X_val_df['Gender'].map(gender_map_reverse)
X_val_df['Breastfeeding'] = X_val_df['Breastfeeding'].map(breastfeeding_map_reverse)

# Konversi y_test dan y_val ke dataframe
y_test_df = pd.DataFrame(y_test, columns=['Stunting'])
y_val_df = pd.DataFrame(y_val, columns=['Stunting'])

# Gabungkan fitur dan label
test_data = pd.concat([X_test_df, y_test_df], axis=1)
val_data = pd.concat([X_val_df, y_val_df], axis=1)

# Simpan ke file CSV
test_data.to_csv('/content/test_data.csv', index=False)
val_data.to_csv('/content/val_data.csv', index=False)

import pickle
from sklearn.preprocessing import StandardScaler, LabelEncoder

# Misalnya, kita punya objek scaler dan label_encoder
scaler = StandardScaler()
label_encoder = LabelEncoder()

# Latih scaler dan label_encoder menggunakan data (contoh)
# scaler.fit(X_train)  # X_train adalah data fitur
# label_encoder.fit(y_train)  # y_train adalah label target

# Simpan scaler ke dalam file .pkl
with open('scaler.pkl', 'wb') as f:
    pickle.dump(scaler, f)

# Simpan label_encoder ke dalam file .pkl
with open('label_encoder.pkl', 'wb') as f:
    pickle.dump(label_encoder, f)

# Untuk memastikan file tersimpan, kita bisa mengecek
import shutil
shutil.move('scaler.pkl', '/content/scaler.pkl')
shutil.move('label_encoder.pkl', '/content/label_encoder.pkl')

print("File scaler.pkl dan label_encoder.pkl berhasil disimpan!")

# Install library untuk cek semua package (jika belum ada)
!pip install pipreqs

# Import library yang diperlukan
import pkg_resources

# Ambil daftar semua library dan versinya
installed_packages = pkg_resources.working_set
package_list = sorted(["{}=={}".format(i.key, i.version) for i in installed_packages])

# Simpan ke file txt
with open('library_versions.txt', 'w') as f:
    for package in package_list:
        f.write(package + '\n')

# Print konfirmasi
print("Daftar library dan versinya sudah disimpan ke library_versions.txt")

# (Opsional) Tampilkan beberapa isinya
with open('library_versions.txt', 'r') as f:
    for _ in range(10):  # tampilkan 10 baris pertama
        print(f.readline().strip())

# Mount Google Drive
from google.colab import drive
drive.mount('/content/drive')

# Install pipreqs (hanya kalau mau, tapi tidak dipakai di metode manual ini)
!pip install pipreqs

# Import library yang dibutuhkan
import pkg_resources

# Daftar nama package yang kamu gunakan
packages_used = [
    'pickle',
    'sklearn',
    'pandas',
    'tensorflow',
    'numpy',
    'seaborn',
    'matplotlib',
    'joblib'
]

# Ambil semua package yang sudah terinstall
installed_packages = {pkg.key: pkg.version for pkg in pkg_resources.working_set}

# Simpan hanya yang kamu gunakan
filtered_packages = {}

for package in packages_used:
    # Karena ada sedikit perbedaan nama package vs modul, kita handle khusus
    if package == 'sklearn':
        real_package = 'scikit-learn'
    else:
        real_package = package

    version = installed_packages.get(real_package)
    if version:
        filtered_packages[real_package] = version
    else:
        print(f"Peringatan: {real_package} tidak ditemukan!")

# Simpan ke file txt di Drive
save_path = '/content/drive/MyDrive/Capstone_DBS/library_versions.txt'

with open(save_path, 'w') as f:
    for pkg, ver in filtered_packages.items():
        f.write(f"{pkg}=={ver}\n")

print(f"Library dan versinya berhasil disimpan di {save_path}")

# (Opsional) tampilkan isi file
with open(save_path, 'r') as f:
    print(f.read())

import shutil
import os

# Mount Google Drive dulu (kalau belum)
from google.colab import drive
drive.mount('/content/drive')

# Path sumber (semua isi /content) dan tujuan
source_folder = '/content'
destination_folder = '/content/drive/MyDrive/Capstone_DBS'

# Pastikan folder tujuan ada, kalau tidak buat
os.makedirs(destination_folder, exist_ok=True)

# Pindahkan semua file (kecuali folder 'drive' itu sendiri agar tidak error)
for item in os.listdir(source_folder):
    if item == 'drive':
        continue  # Skip folder drive
    s = os.path.join(source_folder, item)
    d = os.path.join(destination_folder, item)

    if os.path.isdir(s):
        # Jika item adalah folder, salin seluruh folder
        shutil.copytree(s, d, dirs_exist_ok=True)
    else:
        # Jika file biasa, salin file
        shutil.copy2(s, d)

print(f"Semua file dari /content/ berhasil disalin ke {destination_folder}")